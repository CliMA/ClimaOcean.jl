using Oceananigans.Utils: prettysummary
using Oceananigans.Grids: AbstractGrid
using Oceananigans.BuoyancyFormulations: g_Earth

using Adapt
using Thermodynamics: Liquid
using SurfaceFluxes.Parameters: SurfaceFluxesParameters
using SurfaceFluxes.UniversalFunctions: BusingerParams, BusingerType

using Printf
using Thermodynamics: PhasePartition
using KernelAbstractions.Extras.LoopInfo: @unroll

using Statistics: norm

import Thermodynamics as AtmosphericThermodynamics
import Thermodynamics.Parameters: molmass_ratio

#####
##### Bulk turbulent fluxes based on similarity theory
#####

struct SimilarityTheoryFluxes{FT, UF, R, B, S}
    von_karman_constant :: FT        # parameter
    turbulent_prandtl_number :: FT   # parameter
    gustiness_parameter :: FT        # bulk velocity parameter
    minimum_velocity_scale :: FT     # minimum velocity scale 
    stability_functions :: UF        # functions for turbulent fluxes
    roughness_lengths :: R           # parameterization for turbulent fluxes
    similarity_form :: B             # similarity profile relating atmosphere to interface state
    solver_stop_criteria :: S        # stop criteria for compute_interface_state
end

Adapt.adapt_structure(to, fluxes::SimilarityTheoryFluxes) =
    SimilarityTheoryFluxes(adapt(to, fluxes.von_karman_constant),
                           adapt(to, fluxes.turbulent_prandtl_number),
                           adapt(to, fluxes.gustiness_parameter),
                           adapt(to, fluxes.minimum_velocity_scale),
                           adapt(to, fluxes.stability_functions),
                           adapt(to, fluxes.roughness_lengths),
                           adapt(to, fluxes.similarity_form),
                           adapt(to, fluxes.solver_stop_criteria))


Base.summary(::SimilarityTheoryFluxes{FT}) where FT = "SimilarityTheoryFluxes{$FT}"

function Base.show(io::IO, fluxes::SimilarityTheoryFluxes)
    print(io, summary(fluxes), '\n',
          "‚îú‚îÄ‚îÄ von_karman_constant: ",        prettysummary(fluxes.von_karman_constant), '\n',
          "‚îú‚îÄ‚îÄ turbulent_prandtl_number: ",   prettysummary(fluxes.turbulent_prandtl_number), '\n',
          "‚îú‚îÄ‚îÄ gustiness_parameter: ",        prettysummary(fluxes.gustiness_parameter), '\n',
          "‚îú‚îÄ‚îÄ stability_functions: ",        summary(fluxes.stability_functions), '\n',
          "‚îú‚îÄ‚îÄ roughness_lengths: ",          summary(fluxes.roughness_lengths), '\n',
          "‚îú‚îÄ‚îÄ similarity_form: ",            summary(fluxes.similarity_form), '\n',
          "‚îî‚îÄ‚îÄ solver_stop_criteria: ",       summary(fluxes.solver_stop_criteria))
end

"""
    SimilarityTheoryFluxes(FT::DataType = Float64;
                           gravitational_acceleration = 9.81,
                           von_karman_constant = 0.4,
                           turbulent_prandtl_number = 1,
                           gustiness_parameter = 1,
                           stability_functions = default_stability_functions(FT),
                           roughness_lengths = default_roughness_lengths(FT),
                           similarity_form = LogarithmicSimilarityProfile(),
                           solver_stop_criteria = nothing,
                           solver_tolerance = 1e-8,
                           solver_maxiter = 100)

`SimilarityTheoryFluxes` contains parameters and settings to calculate
air-interface turbulent fluxes using Monin--Obukhov similarity theory.

Keyword Arguments
==================

- `von_karman_constant`: The von Karman constant. Default: 0.4.
- `turbulent_prandtl_number`: The turbulent Prandtl number. Default: 1.
- `gustiness_parameter`: Increases surface fluxes in low wind conditions. Default: 1.
- `stability_functions`: The stability functions. Default: `default_stability_functions(FT)` that follow the
                         formulation of [edson2013exchange](@citet).
- `roughness_lengths`: The roughness lengths used to calculate the characteristic scales for momentum, temperature and
                       water vapor. Default: `default_roughness_lengths(FT)`, formulation taken from [edson2013exchange](@citet).
- `similarity_form`: The type of similarity profile used to relate the atmospheric state to the
                             interface fluxes / characteristic scales.
- `solver_tolerance`: The tolerance for convergence. Default: 1e-8.
- `solver_maxiter`: The maximum number of iterations. Default: 100.
"""
function SimilarityTheoryFluxes(FT::DataType = Oceananigans.defaults.FloatType;
                                von_karman_constant = 0.4,
                                turbulent_prandtl_number = 1,
                                gustiness_parameter = 2,
                                stability_functions = atmosphere_ocean_stability_functions(FT),
                                momentum_roughness_length = MomentumRoughnessLength(FT),
                                temperature_roughness_length = ScalarRoughnessLength(FT),
                                water_vapor_roughness_length = ScalarRoughnessLength(FT),
                                minimum_velocity_scale = 0.5,
                                similarity_form = LogarithmicSimilarityProfile(),
                                solver_stop_criteria = nothing,
                                solver_tolerance = 1e-8,
                                solver_maxiter = 100)

    roughness_lengths = SimilarityScales(momentum_roughness_length,
                                         temperature_roughness_length,
                                         water_vapor_roughness_length)

    if isnothing(solver_stop_criteria)
        solver_tolerance = convert(FT, solver_tolerance)
        solver_stop_criteria = ConvergenceStopCriteria(solver_tolerance, solver_maxiter)
    end

    if isnothing(stability_functions)
        returns_zero = Returns(zero(FT))
        stability_functions = SimilarityScales(returns_zero, returns_zero, returns_zero)
    end

    return SimilarityTheoryFluxes(convert(FT, von_karman_constant),
                                  convert(FT, turbulent_prandtl_number),
                                  convert(FT, gustiness_parameter),
                                  convert(FT, minimum_velocity_scale),
                                  stability_functions,
                                  roughness_lengths,
                                  similarity_form,
                                  solver_stop_criteria)
end

#####
##### Similarity profile types
#####

"""
    LogarithmicSimilarityProfile()

Represent the classic Monin--Obukhov similarity profile, which finds that

```math
œï(z) = Œ†(z) œï_‚òÖ / œ∞
```

where ``œ∞`` is the Von Karman constant, ``œï_‚òÖ`` is the characteristic scale for ``œï``,
and ``Œ†`` is the "similarity profile",

```math
Œ†(h) = \\log(h / ‚Ñì) - œà(h / L) + œà(‚Ñì / L)
```

which is a logarithmic profile adjusted by the stability function ``œà`` and dependent on
the Monin--Obukhov length ``L`` and the roughness length ``‚Ñì``.
"""
struct LogarithmicSimilarityProfile end
struct COARELogarithmicSimilarityProfile end

@inline function similarity_profile(::LogarithmicSimilarityProfile, stability_function, h, ‚Ñì, L)
    Œ∂ = h / L
    œàh = stability_profile(stability_function, Œ∂)
    œà‚Ñì = stability_profile(stability_function, ‚Ñì / L)
    return log(h / ‚Ñì) - œàh + œà‚Ñì
end

@inline function similarity_profile(::COARELogarithmicSimilarityProfile, stability_function, h, ‚Ñì, L)
    Œ∂ = h / L
    œàh = stability_profile(stability_function, Œ∂)
    return log(h / ‚Ñì) - œàh
end

function iterate_interface_fluxes(flux_formulation::SimilarityTheoryFluxes,
                                  T‚Çõ, q‚Çõ, ŒîŒ∏, Œîq, Œîh,
                                  approximate_interface_state,
                                  atmosphere_state,
                                  interface_properties,
                                  atmosphere_properties)

    ‚ÑÇ‚Çê = atmosphere_properties.thermodynamics_parameters
    g  = atmosphere_properties.gravitational_acceleration
    ùí¨‚Çê = atmosphere_state.ùí¨

    # "initial" scales because we will recompute them
    u‚òÖ = approximate_interface_state.u‚òÖ
    Œ∏‚òÖ = approximate_interface_state.Œ∏‚òÖ
    q‚òÖ = approximate_interface_state.q‚òÖ

    # Stability functions for momentum, heat, and vapor
    œàu = flux_formulation.stability_functions.momentum
    œàŒ∏ = flux_formulation.stability_functions.temperature
    œàq = flux_formulation.stability_functions.water_vapor

    # Extract roughness lengths
    ‚Ñìu = flux_formulation.roughness_lengths.momentum
    ‚ÑìŒ∏ = flux_formulation.roughness_lengths.temperature
    ‚Ñìq = flux_formulation.roughness_lengths.water_vapor
    Œ≤  = flux_formulation.gustiness_parameter

    # Compute surface thermodynamic state
    ùí¨‚Çõ = AtmosphericThermodynamics.PhaseEquil_pTq(‚ÑÇ‚Çê, ùí¨‚Çê.p, T‚Çõ, q‚Çõ)

    # Compute Monin--Obukhov length scale depending on a `buoyancy flux`
    b‚òÖ = buoyancy_scale(Œ∏‚òÖ, q‚òÖ, ‚ÑÇ‚Çê, ùí¨‚Çõ, g)

    # Buoyancy flux characteristic scale for gustiness (Edson et al. 2013)
    h_b‚Ñì = atmosphere_state.h_b‚Ñì
    J·µá = - u‚òÖ * b‚òÖ
    U·¥≥ = Œ≤ * cbrt(J·µá * h_b‚Ñì)

    # New velocity difference accounting for gustiness
    Œîu, Œîv = velocity_difference(interface_properties.velocity_formulation,
                                 atmosphere_state,
                                 approximate_interface_state)

    U = sqrt(Œîu^2 + Œîv^2 + U·¥≥^2)
    U = max(U, flux_formulation.minimum_velocity_scale)
    
    # Compute roughness length scales
    ‚Ñìu‚ÇÄ = roughness_length(‚Ñìu, u‚òÖ, U, ùí¨‚Çõ, ‚ÑÇ‚Çê)
    ‚Ñìq‚ÇÄ = roughness_length(‚Ñìq, ‚Ñìu‚ÇÄ, u‚òÖ, U, ùí¨‚Çõ, ‚ÑÇ‚Çê)
    ‚ÑìŒ∏‚ÇÄ = roughness_length(‚ÑìŒ∏, ‚Ñìu‚ÇÄ, u‚òÖ, U, ùí¨‚Çõ, ‚ÑÇ‚Çê)

    # Transfer coefficients at height `h`
    œ∞ = flux_formulation.von_karman_constant
    L‚òÖ = ifelse(b‚òÖ == 0, Inf, - u‚òÖ^2 / (œ∞ * b‚òÖ))
    form = flux_formulation.similarity_form

    œáu = œ∞ / similarity_profile(form, œàu, Œîh, ‚Ñìu‚ÇÄ, L‚òÖ)
    œáŒ∏ = œ∞ / similarity_profile(form, œàŒ∏, Œîh, ‚ÑìŒ∏‚ÇÄ, L‚òÖ)
    œáq = œ∞ / similarity_profile(form, œàq, Œîh, ‚Ñìq‚ÇÄ, L‚òÖ)

    # Recompute
    u‚òÖ = œáu * U
    Œ∏‚òÖ = œáŒ∏ * ŒîŒ∏
    q‚òÖ = œáq * Œîq

    return u‚òÖ, Œ∏‚òÖ, q‚òÖ, U
end

"""
    buoyancy_scale(Œ∏‚òÖ, q‚òÖ, ‚ÑÇ, ùí¨, g)

Return the characteristic buoyancy scale `b‚òÖ` associated with
the characteristic temperature `Œ∏‚òÖ`, specific humidity scale `q‚òÖ`,
surface thermodynamic state `ùí¨`, thermodynamic parameters `‚ÑÇ`,
and gravitational acceleration `g`.

The buoyancy scale is defined in terms of the interface buoyancy flux,

```math
u_‚òÖ b_‚òÖ ‚â° w'b',
```

where `u_‚òÖ` is the friction velocity.
Using the definition of buoyancy for clear air without condensation, we find that

```math
b_‚òÖ = (g / ùíØ‚Çõ) [Œ∏_‚òÖ (1 + Œ¥ q‚Çê) + Œ¥ ùíØ‚Çõ q_‚òÖ] ,
```
where ``ùíØ‚Çê`` is the virtual temperature at the surface, and ``Œ¥ = R·µ• / R_d - 1``,
where ``R·µ•`` is the molar mass of water vapor and ``R_d`` is the molar mass of dry air.

Note that the Monin--Obukhov characteristic length scale is defined
in terms of ``b_‚òÖ`` and additionally the Von Karman constant ``œ∞``,

```math
L_‚òÖ = - u_‚òÖ¬≤ / œ∞ b_‚òÖ .
```
"""
@inline function buoyancy_scale(Œ∏‚òÖ, q‚òÖ, ‚ÑÇ, ùí¨, g)
    ùíØ‚Çê = AtmosphericThermodynamics.virtual_temperature(‚ÑÇ, ùí¨)
    q‚Çê = AtmosphericThermodynamics.vapor_specific_humidity(‚ÑÇ, ùí¨)
    Œµ  = AtmosphericThermodynamics.Parameters.molmass_ratio(‚ÑÇ)
    Œ¥  = Œµ - 1 # typically equal to 0.608

    b‚òÖ = g / ùíØ‚Çê * (Œ∏‚òÖ * (1 + Œ¥ * q‚Çê) + Œ¥ * ùíØ‚Çê * q‚òÖ)

    return b‚òÖ
end

import Statistics

#####
##### Struct that represents a 3-tuple of momentum, heat, and water vapor
#####

struct SimilarityScales{U, T, Q}
    momentum :: U
    temperature :: T
    water_vapor :: Q
end

Base.summary(ss::SimilarityScales) =
    string("SimilarityScales(momentum=", prettysummary(ss.momentum),
           ", temperature=", prettysummary(ss.temperature),
           ", water_vapor=", prettysummary(ss.water_vapor), ")")

Base.show(io::IO, ss::SimilarityScales) = print(io, summary(ss))

@inline stability_profile(œà, Œ∂) = œà(Œ∂)

# Convenience
abstract type AbstractStabilityFunction end
@inline (œà::AbstractStabilityFunction)(Œ∂) = stability_profile(œà, Œ∂)

"""
    EdsonMomentumStabilityFunction{FT}

A struct representing the momentum stability function detailed by [edson2013exchange](@citet).
The formulation hinges on the definition of three different functions:
one for stable atmospheric conditions ``(Œ∂ > 0)``, named ``œà‚Çõ`` and two for unstable conditions,
named ``œà·µ§‚ÇÅ`` and ``œà·µ§‚ÇÇ``.
These stability functions are obtained by regression to experimental data.

The stability parameter for stable atmospheric conditions is defined as
```math
\\begin{align*}
dŒ∂ &= \\min(Œ∂_{\\max}, A‚Å∫ Œ∂) \\\\
œà‚Å∫ &= - B‚Å∫ Œ∂‚Å∫ - C‚Å∫ (Œ∂‚Å∫ - D‚Å∫) \\exp(- dŒ∂) - C‚Å∫ D‚Å∫
\\end{align*}
```

While the stability parameter for unstable atmospheric conditions is calculated
as a function of the two individual stability functions as follows

```math
\\begin{align*}
f‚Åª‚ÇÅ &= (1 - A‚ÅªŒ∂)^{1/4} \\\\
œà‚Åª‚ÇÅ &= (B‚Åª / 2) \\log[(1 + f‚Åª‚ÇÅ + f‚Åª‚ÇÅ¬≤ + f‚Åª‚ÇÅ¬≥) / B‚Åª] - ‚àöB‚Åª \\mathrm{atan}(f‚Åª‚ÇÅ) - C‚Åª \\\\
\\\\
f‚Åª‚ÇÇ &= ‚àõ(1 - D‚ÅªŒ∂) \\\\
œà‚Åª‚ÇÇ &= (E‚Åª / 2) \\log[(1 + f‚Åª‚ÇÇ + f‚Åª‚ÇÇ¬≤) / E‚Åª]- ‚àöE‚Åª \\mathrm{atan}[(1 + 2f‚Åª‚ÇÇ) / ‚àöE‚Åª] + F‚Åª \\\\
\\\\
f   &= Œ∂¬≤ / (1 + Œ∂¬≤) \\\\
œà‚Åª  &= (1 - f) œà‚Åª‚ÇÅ + f œà‚Åª‚ÇÇ
\\end{align*}
```

The superscripts ``+`` and ``-`` indicate if the parameter applies to the
stability function for _stable_ or _unstable_ atmospheric conditions, respectively.
"""
@kwdef struct EdsonMomentumStabilityFunction{FT} <: AbstractStabilityFunction
    Œ∂max :: FT = 50.0
    A‚Å∫   :: FT = 0.35
    B‚Å∫   :: FT = 0.7
    C‚Å∫   :: FT = 0.75
    D‚Å∫   :: FT = 5/0.35
    A‚Åª   :: FT = 15.0
    B‚Åª   :: FT = 2.0
    C‚Åª   :: FT = œÄ/2
    D‚Åª   :: FT = 10.15
    E‚Åª   :: FT = 3.0
    F‚Åª   :: FT = œÄ / sqrt(3)
end

@inline function stability_profile(œà::EdsonMomentumStabilityFunction, Œ∂)
    Œ∂max = œà.Œ∂max
    A‚Å∫   = œà.A‚Å∫
    B‚Å∫   = œà.B‚Å∫
    C‚Å∫   = œà.C‚Å∫
    D‚Å∫   = œà.D‚Å∫
    A‚Åª   = œà.A‚Åª
    B‚Åª   = œà.B‚Åª
    C‚Åª   = œà.C‚Åª
    D‚Åª   = œà.D‚Åª
    E‚Åª   = œà.E‚Åª
    F‚Åª   = œà.F‚Åª

    Œ∂‚Åª = min(zero(Œ∂), Œ∂)
    Œ∂‚Å∫ = max(zero(Œ∂), Œ∂)
    dŒ∂ = min(Œ∂max, A‚Å∫ * Œ∂‚Å∫)

    # Stability parameter for _stable_ atmospheric conditions
    œà‚Å∫ = - B‚Å∫ * Œ∂‚Å∫ - C‚Å∫ * (Œ∂‚Å∫ - D‚Å∫) * exp(- dŒ∂) - C‚Å∫ * D‚Å∫

    # Stability parameter for _unstable_ atmospheric conditions
    f‚Åª‚ÇÅ = sqrt(sqrt(1 - A‚Åª * Œ∂‚Åª))
    œà‚Åª‚ÇÅ = B‚Åª * log((1 + f‚Åª‚ÇÅ) / B‚Åª) + log((1 + f‚Åª‚ÇÅ^2) / B‚Åª) - B‚Åª * atan(f‚Åª‚ÇÅ) + C‚Åª

    f‚Åª‚ÇÇ = cbrt(1 - D‚Åª * Œ∂‚Åª)
    œà‚Åª‚ÇÇ = E‚Åª / 2 * log((1 + f‚Åª‚ÇÇ + f‚Åª‚ÇÇ^2) / E‚Åª) - sqrt(E‚Åª) * atan( (1 + 2f‚Åª‚ÇÇ) / sqrt(E‚Åª)) + F‚Åª

    f  = Œ∂‚Åª^2 / (1 + Œ∂‚Åª^2)
    œà‚Åª = (1 - f) * œà‚Åª‚ÇÅ + f * œà‚Åª‚ÇÇ

    return ifelse(Œ∂ < 0, œà‚Åª, œà‚Å∫)
end

"""
    EdsonScalarStabilityFunction{FT}

A struct representing the scalar stability function detailed by [edson2013exchange](@citet).
The formulation hinges on the definition of two different functions:
one for stable atmospheric conditions ``(Œ∂ > 0)``, named ``œà‚Å∫`` and one for unstable conditions,
named ``œà‚Åª``.

These stability functions are obtained by regression to experimental data.

The stability parameter for stable atmospheric conditions is defined as

```math
\\begin{align*}
dŒ∂ &= \\min(Œ∂_{\\max}, A‚Å∫Œ∂) \\\\
œà‚Å∫ &= - (1 + B‚Å∫ Œ∂)^{C‚Å∫} - B‚Å∫ (Œ∂ - D‚Å∫) \\exp( - dŒ∂) - E‚Å∫
\\end{align*}
```

While the stability parameter for unstable atmospheric conditions is calculated
as a function of the two individual stability functions as follows
```math
\\begin{align*}
f‚Åª‚ÇÅ &= ‚àö(1 - A‚ÅªŒ∂) \\\\
œà‚Åª‚ÇÅ &= B‚Åª \\log[(1 + f‚Åª‚ÇÅ) / B‚Åª] + C‚Åª \\\\
\\\\
f‚Åª‚ÇÇ &= ‚àõ(1 - D‚ÅªŒ∂) \\\\
œà‚Åª‚ÇÇ &= (E‚Åª / 2) \\log[(1 + f‚Åª‚ÇÇ + f‚Åª‚ÇÇ¬≤) / E‚Åª] - ‚àöE‚Åª \\mathrm{atan}[(1 + 2f‚Åª‚ÇÇ) / ‚àöE‚Åª] + F‚Åª \\\\
\\\\
f   &= Œ∂¬≤ / (1 + Œ∂¬≤) \\\\
œà‚Åª  &= (1 - f) œà‚Åª‚ÇÅ + f œà‚Åª‚ÇÇ
\\end{align*}
```

The superscripts ``+`` and ``-`` indicate if the parameter applies to the
stability function for _stable_ or _unstable_ atmospheric conditions, respectively.
"""
@kwdef struct EdsonScalarStabilityFunction{FT} <: AbstractStabilityFunction
    Œ∂max :: FT = 50.0
    A‚Å∫   :: FT = 0.35
    B‚Å∫   :: FT = 2/3
    C‚Å∫   :: FT = 3/2
    D‚Å∫   :: FT = 14.28
    E‚Å∫   :: FT = 8.525
    A‚Åª   :: FT = 15.0
    B‚Åª   :: FT = 2.0
    C‚Åª   :: FT = 0.0
    D‚Åª   :: FT = 34.15
    E‚Åª   :: FT = 3.0
    F‚Åª   :: FT = œÄ / sqrt(3)
end

@inline function stability_profile(œà::EdsonScalarStabilityFunction, Œ∂)
    Œ∂max = œà.Œ∂max
    A‚Å∫   = œà.A‚Å∫
    B‚Å∫   = œà.B‚Å∫
    C‚Å∫   = œà.C‚Å∫
    D‚Å∫   = œà.D‚Å∫
    E‚Å∫   = œà.E‚Å∫
    A‚Åª   = œà.A‚Åª
    B‚Åª   = œà.B‚Åª
    C‚Åª   = œà.C‚Åª
    D‚Åª   = œà.D‚Åª
    E‚Åª   = œà.E‚Åª
    F‚Åª   = œà.F‚Åª

    Œ∂‚Åª = min(zero(Œ∂), Œ∂)
    Œ∂‚Å∫ = max(zero(Œ∂), Œ∂)
    dŒ∂ = min(Œ∂max, A‚Å∫ * Œ∂‚Å∫)

    # stability function for stable atmospheric conditions
    œà‚Å∫ = - (1 + B‚Å∫ * Œ∂‚Å∫)^C‚Å∫ - B‚Å∫ * (Œ∂‚Å∫ - D‚Å∫) * exp(-dŒ∂) - E‚Å∫

    # Stability parameter for _unstable_ atmospheric conditions
    f‚Åª‚ÇÅ = sqrt(1 - A‚Åª * Œ∂‚Åª)
    œà‚Åª‚ÇÅ = B‚Åª * log((1 + f‚Åª‚ÇÅ) / B‚Åª) + C‚Åª

    f‚Åª‚ÇÇ = cbrt(1 - D‚Åª * Œ∂‚Åª)
    œà‚Åª‚ÇÇ = E‚Åª / 2 * log((1 + f‚Åª‚ÇÇ + f‚Åª‚ÇÇ^2) / E‚Åª) - sqrt(E‚Åª) * atan((1 + 2f‚Åª‚ÇÇ) / sqrt(E‚Åª)) + F‚Åª

    f  = Œ∂‚Åª^2 / (1 + Œ∂‚Åª^2)
    œà‚Åª = (1 - f) * œà‚Åª‚ÇÅ + f * œà‚Åª‚ÇÇ

    return ifelse(Œ∂ < 0, œà‚Åª, œà‚Å∫)
end

# Edson et al. (2013)
function atmosphere_ocean_stability_functions(FT=Oceananigans.defaults.FloatType)
    œàu = EdsonMomentumStabilityFunction{FT}()
    œàc = EdsonScalarStabilityFunction{FT}()
    return SimilarityScales(œàu, œàc, œàc)
end

Base.summary(::EdsonMomentumStabilityFunction{FT}) where FT = "EdsonMomentumStabilityFunction{$FT}"
Base.summary(::EdsonScalarStabilityFunction{FT}) where FT = "EdsonScalarStabilityFunction{$FT}"

Base.show(io, ::EdsonMomentumStabilityFunction{FT}) where FT = print(io, "EdsonMomentumStabilityFunction{$FT}")
Base.show(io, ::EdsonScalarStabilityFunction{FT}) where FT = print(io, "EdsonScalarStabilityFunction{$FT}")

#####
##### From Grachev et al. (2007), for stable boundary layers
#####

@kwdef struct ShebaMomentumStabilityFunction{FT} <: AbstractStabilityFunction
    a :: FT = 6.5
    b :: FT = 1.3
end

# @inline (œà::ShebaMomentumStabilityFunction)(Œ∂) = 1 + œà.a * Œ∂ * cbrt(1 + Œ∂) / (œà.b + Œ∂)
@inline function stability_profile(œà::ShebaMomentumStabilityFunction, Œ∂)
    a = œà.a
    b = œà.b
    Œ∂‚Å∫ = max(zero(Œ∂), Œ∂)
    z = cbrt(1 + Œ∂‚Å∫)
    B = cbrt((1 - b) / b)

    rt3 = sqrt(3)
    Œ®‚ÇÅ = - 3 * a * (z - 1) / b
    Œ®‚ÇÇ = a * B / 2b * (2 * log((z + B) / (1 + B))
                       - log((z^2 - B * z + B^2) / (1 - B + B^2))
                       + 2 * rt3 * (atan((2z - B) / (rt3 * B)) - atan((2 - B) / (rt3 * B))))

    return Œ®‚ÇÅ + Œ®‚ÇÇ
end

@kwdef struct ShebaScalarStabilityFunction{FT} <: AbstractStabilityFunction
    a :: FT = 5.0
    b :: FT = 5.0
    c :: FT = 3.0
end

@inline function stability_profile(œà::ShebaScalarStabilityFunction, Œ∂)
    a = œà.a
    b = œà.b
    c = œà.c
    B = sqrt(c^2 - 4)
    Œ∂‚Å∫ = max(zero(Œ∂), Œ∂)

    Œ®‚ÇÅ = - b/2 * log(1 + c * Œ∂‚Å∫ + Œ∂‚Å∫^2)
    Œ®‚ÇÇ = (b * c / 2B - a / B) *
        (log((2Œ∂‚Å∫ + c - B) / (2Œ∂‚Å∫ + c + B)) - log((c - B) / (c + B)))

    return Œ®‚ÇÅ + Œ®‚ÇÇ
end

#####
##### From Paulson (1970), for unstable boundary layers
#####

@kwdef struct PaulsonMomentumStabilityFunction{FT} <: AbstractStabilityFunction
    a :: FT = 16.0
    b :: FT = œÄ/2
end

@inline function stability_profile(œà::PaulsonMomentumStabilityFunction, Œ∂)
    a = œà.a
    b = œà.b
    Œ∂‚Åª = min(zero(Œ∂), Œ∂)
    z = sqrt(sqrt((1 - a * Œ∂‚Åª)))

    Œ®‚ÇÅ = 2 * log((1 + z) / 2)
    Œ®‚ÇÇ = log((1 + z^2) / 2)
    Œ®‚ÇÉ = - 2 * atan(z)

    return Œ®‚ÇÅ + Œ®‚ÇÇ + Œ®‚ÇÉ + b
end

@kwdef struct PaulsonScalarStabilityFunction{FT} <: AbstractStabilityFunction
    a :: FT = 16.0
end

@inline function stability_profile(œà::PaulsonScalarStabilityFunction, Œ∂)
    a = œà.a
    Œ∂‚Åª = min(zero(Œ∂), Œ∂)
    z = sqrt(sqrt((1 - a * Œ∂‚Åª)))
    return 2 * log((1 + z^2) / 2)
end

struct SplitStabilityFunction{S, U}
    stable :: S
    unstable :: U
end

Base.summary(ss::SplitStabilityFunction) = "SplitStabilityFunction"
Base.show(io::IO, ss::SplitStabilityFunction) = print(io, "SplitStabilityFunction")

@inline function stability_profile(œà::SplitStabilityFunction, Œ∂)
    Œ®_stable = stability_profile(œà.stable, Œ∂)
    Œ®_unstable = stability_profile(œà.unstable, Œ∂)
    stable = Œ∂ > 0
    return ifelse(stable, Œ®_stable, Œ®_unstable)
end

function atmosphere_sea_ice_stability_functions(FT=Oceananigans.defaults.FloatType)
    unstable_momentum = PaulsonMomentumStabilityFunction{FT}()
    stable_momentum = ShebaMomentumStabilityFunction{FT}()
    momentum = SplitStabilityFunction(stable_momentum, unstable_momentum)

    unstable_scalar = PaulsonScalarStabilityFunction{FT}()
    stable_scalar = ShebaScalarStabilityFunction{FT}()
    scalar = SplitStabilityFunction(stable_scalar, unstable_scalar)

    return SimilarityScales(momentum, scalar, scalar)
end
